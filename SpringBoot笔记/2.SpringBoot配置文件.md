# SpringBoot配置文件

## 1.配置文件

springboot全局配置文件，名字是固定的

application.properties

application.yml

作用是：修改SpringBoot项目自动配置的默认值，SpringBoot在底层在给自动配置好了；

YAML（YAML aint markup language）；YAML a markup langeuage（是标价语言），YAML is not a Markup language（不是标记语言）

标记语言；
		以前的配置文件，大多数都是xml文件，
		yaml是以数据为中心

```yaml
server:
	port: 8081
```

xml:

```xml
<server>
	<port>8081</port>
</server>
```

## 2.YAML基本语法

### 1.基本语法

k:(**空格**)v:表示一对键值对（**空格必须有**），以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的

```yaml
server:
	port: 8081
	path: /hello
```

属性和值也是大小写敏感的；

### 2.值的写法

**字面量：普通的值（数字，字符串，布尔值）**

k：v:字面直接来写；

​		字符串默认不用加上单引号或者是双引号；
​		""：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本省表示的意思
​		name:"zhansan \n lisi" 输出：zhangsan 换行 lisi

​		’‘；单引号；会转义字符串里面的特殊字符，
​		name:'zhansan \n lisi' 输出：zhangsan \n lisi

**对象，map（属性和值）（键值对）**

k：v:  在下一行来写对象的属性和值的关系；注意缩进

​	对象还是k;v的方式

```yaml
friends:
​	lastname: zhansan
​	age:20
```

行内写法：

```yaml
friends{lastname: zhangsan,age: 18}
```

**数组（List,Set）**

用-值表示数组中的一个元素

```yaml
pets:
 - cat
 - dog
 - pig
```

行内写法：

```yaml
pets:[cat,dog,pig]
```

### 3.获取配置文件值，文件值注入

配置文件

````yaml
person:
  lastName: zhansan
  age: 18
  boss: false
  birth: 2017/1/12
  maps: {k1: v1,k2: v2}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: 小狗
    age: 12
````

javaBean:

```java

/**将配置文静中配置的每个属性映射到这个组件中*
@ConfigurationProperties:告诉SpringBoot将本类中的说有属性和配置文件中的配置进行绑定
    prefix = “persion";配置文件中哪个下面的索性进行映射
 只有这个组件是容器中的组件，才可以提供容器中的@ConfigurationProperties功能
 *
 *
 */
@Component
@ConfigurationProperties(prefix = "person")
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map<String,Object> maps;
    private List<Object> lists;
    private Dog dog;

    @Override
    public String toString() {
        return "Person{" +
                "lastName='" + lastName + '\'' +
                ", age=" + age +
                ", boss=" + boss +
                ", birth=" + birth +
                ", maps=" + maps +
                ", lists=" + lists +
                ", dog=" + dog +
                '}';
    }
}
```

导入配置文件处理器，在以后导入的时候可以挺有提示

```xml
        <!--   导入配置文件处理器，配置文件进行绑定就会有提示   -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
```

* @Value获取值和@ConfigurationProperties的区别

	|                | @ConfigurationProperties | @Value     |
	| -------------- | ------------------------ | ---------- |
	| 功能           | 批量注入配置文件中的属性 | 一个个指定 |
	| Spel           | 不支持                   | 支持       |
	| 松散绑定       | 支持                     | 不支持     |
	| JSR303数据校验 | 支持                     | 不支持     |
	| 复杂类型封装   | 支持                     | 不支持     |

	配置文件yml和properties他们都可以获取到值；

	如果说，我们只是在某个业务逻辑中需要获取配置文件中的某项值，使用@Value

	若我们专门编写了javaBean和配置文件进行了映射，就直接使用@ConfigurationProperties

	* **数据校验**

		```java
		@Component
		@ConfigurationProperties(prefix = "person")
		@Validated  // 数据校验
		public class Person {
		    /**
		     * <bean class="Person">
		     *     <property name="lastName" valu="字面量/ ${key} 从环境变量，配置文件中获取值/#{SPel}"></property>
		     * </bean>
		     * */
		    private String lastName;
		    private Integer age;
		    private Boolean boss;
		    private Date birth;
		
		    private Map<String,Object> maps;
		    private List<Object> lists;
		    private Dog dog;
		    
		}
		```

	
### 4.@PropertySource和@ImportResource

**@PropertySource** ：价值指定的配置文件；

```java
@Component
@PropertySource(value={"classpath:person.properties"})
@ConfigurationProperties(prefix = "person")

public class Person {}
```

person.properties
![image-20201226173502397](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226173502397.png)

**@ImportResource**：导入spring的配置文件，让配置文件中的内容生效；

SpringBoot里面没有Spring的配置文件，自己编写的配置文件不能够自动识别；想让Spring的配置文件加载进来，@ImportResource标注在配置类上（不建议这样来用）

![image-20201226174452734](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226174452734.png)

SpringBoot中推荐的方法：使用全注解的方法

* 配置类--Spring配置文件,用配置类的方法来给容器中添加组件

```java
package com.cqupt.springboot02config.config;

import com.cqupt.springboot02config.service.HelloService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 知名当前的类是配置类
/**
 * 在配置文件中是用<bean></>来配置的
 * */
@Configuration
public class MyAppConfig {

    // 将方法的返回值添加在容器中，容器中的这个组件的id就是这个方法名
    @Bean
    public HelloService helloService(){
        System.out.println("我使用了配置类来配置了一个组件HelloService");
        return new HelloService();
    }

}

```

Q:

下面的一个test有问题

![image-20201226195413022](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226195413022.png)

不能有返回值，只能是void

### 5.配置文件的占位符

* 1.**随机数**

* 2.占位符获取之前配置的值，如果没有可以用冒号来指定默认的值

	```yaml
	server:
	  port: 8081
	
	person:
	  lastName: ${random.uuid}
	  age: ${random.int}
	  boss: false
	  birth: 2017/1/12
	  maps: {k1: v1,k2: v2}
	  lists:
	    - lisi
	    - zhaoliu
	  dog:
	    name: ${person.lastName}_dog
	    age: 12
	```

### 6.profile

* 1.多profile文件

* ![image-20201226201243909](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226201243909.png)

	默认使用的是application.properties 配置文件

* 2.使用yaml文件来写，多文档块模式

	![image-20201226201703384](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226201703384.png)

* 3.激活指定profile文件

	* 1.在配置文件中指定``spring.profiles.active=dev``来进行激活相应的配置环境
	* 2.命令行模式激活
		* ``--spring.profiles.active=dev``
	* 3.在运行jar打包文件的时候对其进行赋值 ``java -jar jar包名字 --spring.profiles.active=dev``进行profile文件的激活

	* 4.虚拟接参数  ``-Dspring.profiles.active=dev``

### 7.配置文件的加载位置

![image-20201226203254162](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226203254162.png)

**先根目录在classpath，先config在默认**，高优先级的会覆盖低优先级的配置，而且会互不配置
**还可以通过spring.config.location改变默认的配置文件位置**
项目打包好以后，我们可以使用明令行启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载这些配置文件共同器作用来

### 8.外部配置加载顺序（spring也可以从以下位置进行配置，优先级从高到底，高优先级配置会覆盖低优先级配置）

![image-20201226220649808](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201226220649808.png)

红色部分是需要重点来关注的，其他可以只了解即可。

**优先加载带profiled的，然后jar包外先jar包内**寻找，再来加载不带profile的；

Q:springboot无法打包？

![打包出错误](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201227110444793.png)

因为在多个位置配置了application.properties，所以打包会失败

![image-20201227112941288](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201227112941288.png)

好像直接java -jar 没有优先使用profile的配置文件？

### 9.自动配置原理

配置文件能配置的属性参照

自动配置原理

* 1.Springboot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration
* 2.@EnableAutoConfiguration的作用
	* 利用EnableAutoConfigurationImportSelector给容器中导入一些组件，
	* 导入插件selectImports()方法中的内容；
	* List<String> configurations = getCandidateConfigurations(annotationMetadata,attributes);获取候选的配置，
		- ``SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());``扫描jar包下面的所有的类名，把扫描到的内容包装成properties对象，从properties对象中获取到EnableAutoConfiguration.class类对应的值，然后把它们加载到组件中
	* 将类路径下的META-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到容器中。

![image-20201227120158325](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201227120158325.png)

每一个这样的xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们自动配置

* 1.每一个自动配置类自动进行配置

* 2.以HttpEncodingAutoConfiguration为例解释自动配置原理

	```java
	@Configuration(
	    proxyBeanMethods = false
	)// 表示这是一个配置类
	@EnableConfigurationProperties({ServerProperties.class})// 启用指定类的ConfigurationProperties功能，将配置文件中对应的值和ServerProperties类进行绑定起来
	
	// Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类才会生效，是web项目才会生效
	@ConditionalOnWebApplication(
	    type = Type.SERVLET
	)
	
	// 判断当前的项目是放有这个类，SpringMVC中进行乱码解决的拦截器
	@ConditionalOnClass({CharacterEncodingFilter.class})
	
	// 判断配置文件中是否存在某个配置 server.servlet.encoding;如果不存在也是成立的
	// 即使不配置也是默认生效的
	@ConditionalOnProperty(
	    prefix = "server.servlet.encoding",
	    value = {"enabled"},
	    matchIfMissing = true
	)
	public class HttpEncodingAutoConfiguration {
	    
	    //它已经和springboot的配置文件进行映射了
	    private final Encoding properties;
	
	    // 只有一个有参构造器的情况下，参数的值就会从容器中拿
	    public HttpEncodingAutoConfiguration(ServerProperties properties) {
	        this.properties = properties.getServlet().getEncoding();
	    }
	    
	    // 给容器中添加组件
	    @Bean 
	    @ConditionalOnMissingBean
	    public CharacterEncodingFilter characterEncodingFilter() {
	        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
	        filter.setEncoding(this.properties.getCharset().name());
	        		                      	filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));
	        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));
	        return filter;
	    }
	}
	```

	根据当前不同的条件判断，决定这个配置类是否生效？

	

	ServerProperties.java

	```java
	
	@ConfigurationProperties(
	    prefix = "server",
	    ignoreUnknownFields = true
	)
	public class ServerProperties {
	    private Integer port;
	    private InetAddress address;
	    @NestedConfigurationProperty
	    private final ErrorProperties error = new ErrorProperties();
	    private ServerProperties.ForwardHeadersStrategy forwardHeadersStrategy;
	    private String serverHeader;
	    private DataSize maxHttpHeaderSize = DataSize.ofKilobytes(8L);
	    private Shutdown shutdown;
	    @NestedConfigurationProperty
	    private Ssl ssl;
	    @NestedConfigurationProperty
	    private final Compression compression;
	    @NestedConfigurationProperty
	    private final Http2 http2;
	    private final ServerProperties.Servlet servlet;
	    private final ServerProperties.Tomcat tomcat;
	    private final ServerProperties.Jetty jetty;
	    private final ServerProperties.Netty netty;
	    private final ServerProperties.Undertow undertow;
	
	    public ServerProperties() {
	        this.shutdown = Shutdown.IMMEDIATE;
	        this.compression = new Compression();
	        this.http2 = new Http2();
	        this.servlet = new ServerProperties.Servlet();
	        this.tomcat = new ServerProperties.Tomcat();
	        this.jetty = new ServerProperties.Jetty();
	        this.netty = new ServerProperties.Netty();
	        this.undertow = new ServerProperties.Undertow();
	    }
	}
	```

精髓：

* 1.SpringBoot启动会加载大量的自动配置类
* 2.我们看我们需要的功有没有springBoot默认写好的配置类
* 3.我们再看这个自动配置类到底配置了哪些组件，
* 4.给容器中自动配置类添加组件的时候，会从properties类中获取默写属性，这些属性我们就可以在配置文件中指定这些属性的值；

给容器中添加组件，xxxxProperties封装配置

#### 1细节

##### 1.@Conditional作用

作用：必须是@Conditional指定的条件成立，才能给容器中添加组件，配置里面的所有内容才会生效。

![image-20201227213152625](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201227213152625.png)

**自动配置类必须在一定的条件下才能生效，**
怎么知道哪些自动配置类生效了、可以在主配置文件里面使用``debug=true``

![开启debug之后可以看到哪些类启动](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20201227213841405.png)