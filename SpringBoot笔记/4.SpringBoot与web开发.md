[TOC]



-----



使用springBoot：

* **1.创建springboot应用，选中需要的场景**
* **2.SpringBoot已经默认将这些场景创建好了，只需要在配置文件中指定少量的配置就可以运行起来**
* **3.自己编写业务代码；**

**自动配置原理？**

xxxAutoConfiguration是给我们用来自动配置的注解，
xxxProperties：配置类

# 1.SpringBoot对静态资源的映射规则

```java

public void addResourceHandlers(ResourceHandlerRegistry registry) {
            if (!this.resourceProperties.isAddMappings()) {
                logger.debug("Default resource handling disabled");
            } else {
                Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
                CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
                if (!registry.hasMappingForPattern("/webjars/**")) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{"/webjars/**"}).addResourceLocations(new String[]{"classpath:/META-INF/resources/webjars/"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl).setUseLastModified(this.resourceProperties.getCache().isUseLastModified()));
                }

                String staticPathPattern = this.mvcProperties.getStaticPathPattern();
                if (!registry.hasMappingForPattern(staticPathPattern)) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl).setUseLastModified(this.resourceProperties.getCache().isUseLastModified()));
                }

            }
        }

```

* 1所有的/webjars/** 的资源都去class:/META-INF/resources/webjars/找资源；
* webjars：以jar包的方式来引入静态资源，参考网址[webjar:](https://www.webjars.org/)
* ![image-20210101203346353](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210101203346353.png)

```xml
localhost:8080/webjars/jquery/3.5.1/jquery.js
```

![image-20210101203715453](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210101203715453.png)

* 2."/**"访问当前项目的任何资源（静态资源的文件夹）

* ```
	"classpath:/META-INF/resources/"
	"classpath:/resources/"
	"classpath:/static"
	"classpath:/public"
	```

* 3.欢迎页；静态资源文件下的所有index页面；被“/**”映射；

	localhost：8080/   找index页面

* 4.所有的**/favicon.ico都在静态资源文件夹下面找,标题的图标

# 2.模板引擎

JSP，Velocity，Freemarker,Thymeleaf

![image-20210101205841258](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210101205841258.png)

SpringBoot推荐的是：thymelef，语法简单，功能强大

## 1.引入thymelef

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

## 2.Thymeleaf的语法和使用

```java
@ConfigurationProperties(
    prefix = "spring.thymeleaf"
)
public class ThymeleafProperties {
    // 只要我们将html页面放到classpath:/templates,Thymeleaf就会给我们自动进行渲染
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = "classpath:/templates/";
    public static final String DEFAULT_SUFFIX = ".html";
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = "classpath:/templates/";
    private String suffix = ".html";
    private String mode = "HTML";
    private Charset encoding;
    private boolean cache;
    private Integer templateResolverOrder;
    private String[] viewNames;
    private String[] excludedViewNames;
    private boolean enableSpringElCompiler;
    private boolean renderHiddenMarkersBeforeCheckboxes;
    private boolean enabled;
    private final ThymeleafProperties.Servlet servlet;
    private final ThymeleafProperties.Reactive reactive;
```

语法查看thymeleaf的官方网站

* 1.导入thymeleaf的命名空间

	``<html lang="en" xmlns:th="http://www.thymeleaf.org">``

## 3.语法规则

* 1·th:text 改变当前元素里面的内容

	使用th改变任意html的元素值

* 2.表达式

	```properties
	${} #获取比变量值
		1.获取对象的属性，调用方法
		2.获取内置的基本对象 ${session.foo}
		3.内置的工具对象：
	*{}  # 变量的选择表达式 和${}在功能上是一样的，补充了一些功能，配置th:object来使用的
	#{} 获取国际化内容的,在登录页面或者其他html页面可以点击按钮显示中文和其他语言，即为国际化功能
	@{}：定义url链接的
	~{}：片段引用的表达式
		<div th:insert="~{commons:main}">
		<div>
	```

	th:replace语法；
	
	```html
	// todo	
	<body>
			<!--引入topbar-->
			<div th:replace="commons/bar::topbar"></div>
			<div class="container-fluid">
				<div class="row">
					<!--引入sidebar-->
					<div th:replace="commons/bar::#sidebar(activeUri='main.html')"></div>
	```
	
	
	
	![补充功能](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210102192144425.png)



Spring MVC Auto-configuration

以下是springboot对springmvc的自动配置：

Spring Boot provides auto-configuration for Spring MVC that works well with most applications.

The auto-configuration adds the following features on top of Spring’s defaults:

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.
	- 自动配置了视图解析器（根据方法的返回值得到视图对象view，视图对象决定），视图决定对象如何渲染，转发，重定向
	  ContentNegotiatingViewReslver组合所有的视图解析器
	- 如何定制：可以给容器中添加一个视图解析器，自动的将其组合起来
- Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-static-content))).
- Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.
	- Converter 类型转换器
	- Formatter格式转换器，时间格式
	- Genericconverter
- Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-message-converters)).
	- HttpMessageConverters,SpringMVC中用来转换http请求和响应的；User--json
	- HttpMessageConverters是从容器中确定的 ，获取所有的HttpMessageConverter；自己添加HttpMessageConverter只需要将自己的组件注册到容器中（@Bean，@Component）
- Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-message-codes)).
	* ``MessageCodesResolver``:定义错误代码生成规则的
- Static `index.html` support.
- Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-web-binding-initializer)).
	* ``ConfigurableWebBindingInitializer``，初始化web数据绑定器,也可以自定义配置，添加到组件中可以自定义

## 4.修改SpringBoot的默认配置

* 1.SpringBoot在自动配置一个组件的时候，先看用户是否有自动配置相关的组件（@Bean，@Component），若果有就用用户自己配置的，否则就用默认的配置的组件；如果有些组件可以有多个，就会将用户配置的和自己默认的配置组合起来使用；
* 2.

# 3.实验CRUD

## 1.国际化

* 1.配置国际化配置文件
* ![image-20210105165606445](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210105165606445.png)

* 2.SpringBoot自动配置了管理好国际怀资源文件的代码

	```java
	
	@AutoConfigureOrder(-2147483648)
	@Conditional({MessageSourceAutoConfiguration.ResourceBundleCondition.class})
	@EnableConfigurationProperties
	public class MessageSourceAutoConfiguration {
	    private static final Resource[] NO_RESOURCES = new Resource[0];
	
	    public MessageSourceAutoConfiguration() {
	    }
	
	    @Bean
	    @ConfigurationProperties(
	        prefix = "spring.messages"
	    )
	    public MessageSourceProperties messageSourceProperties() {
	        return new MessageSourceProperties();
	    }
	
	    @Bean
	    public MessageSource messageSource(MessageSourceProperties properties) {
	        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
	        if (StringUtils.hasText(properties.getBasename())) {
	            messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));
	        }
	
	        if (properties.getEncoding() != null) {
	            messageSource.setDefaultEncoding(properties.getEncoding().name());
	        }
	
	        messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
	        Duration cacheDuration = properties.getCacheDuration();
	        if (cacheDuration != null) {
	            messageSource.setCacheMillis(cacheDuration.toMillis());
	        }
	
	        messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
	        messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
	        return messageSource;
	    }
	}
	```

* 3.html中编写

	```html
	<!DOCTYPE html>
	<html lang="en"  xmlns:th="http://www.thymeleaf.org">
		<head>
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
			<meta name="description" content="">
			<meta name="author" content="">
			<title>Signin Template for Bootstrap</title>
			<!-- Bootstrap core CSS -->
			<link href="/asserts/css/bootstrap.min.css"  rel="stylesheet">
			<!-- Custom styles for this template -->
			<link href="/asserts/css/signin.css"  rel="stylesheet">
		</head>
		<body class="text-center">
			<form class="form-signin" action="dashboard.html" th:action="@{/user/login}" method="post">
				<img class="mb-4" src="/asserts/img/bootstrap-solid.svg" th:src="@{/asserts/img/bootstrap-solid.svg}" alt="" width="72" height="72">
	<!--			<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>-->
				<h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1>
				<!--判断-->
				<p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
				<label class="sr-only" th:text="#{login.username}">Username</label>
				<input type="text"  name="username" class="form-control" placeholder="Username"  required="" autofocus="">
				<label class="sr-only" th:text="#{login.password}">Password</label>
				<input type="password" name="password" class="form-control" placeholder="Password"  required="">
				<div class="checkbox mb-3">
					<label>
	          			<input type="checkbox" value="remember-me"/> [[#{login.remember}]]
	        		</label>
				</div>
				<button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.button}">Sign in</button>
				<p class="mt-5 mb-3 text-muted">© 2017-2018</p>
				<a class="btn btn-sm" th:href="@{/index.html(l='zh_CN')}">中文</a>
				<a class="btn btn-sm" th:href="@{/index.html(l='en_US')}">English</a>
			</form>
		</body>
	
	</html>
	```

	效果：页面可以根据浏览器的首选语言来切换国际化。



原理：

​	国际化Local（区域信息对象）；LocalResolver（获取区域信息对象）

1.定义自己的LocaleResolver,区域信息解析器

```java
public class MyLocaleResolver implements LocaleResolver {

    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String l = request.getParameter("l");
        Locale locale = Locale.getDefault();
        if(!StringUtils.isEmpty(l)){
            String[] split = l.split("_");
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }


    //
}
```

2.将配置加入容器中生效

```java

@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter{

    @Override
    public void addViewControllers(ViewControllerRegistry registry){
        registry.addViewController("/test").setViewName("success");
    }


    @Bean
    public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
        WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("login");
                registry.addViewController("/index.html").setViewName("login");
            }
        };
        return adapter;
    }

    // 将自己定义的Mylocaleresolver组件添加进来

    @Bean
    public LocaleResolver localeResolver(){
        return new MyLocaleResolver();
    }
}

```

## 2.登录根据Session进行拦截

使用拦截器来做登录检查,在执行操作前进行拦截检查

```java
package com.cqupt.springboot04webresultcrud.component;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 进行登录检查
 * */
public class LoginHandlerInterceptor implements HandlerInterceptor {

    // 目标方法执行之前
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("i am here");
        Object userName = request.getSession().getAttribute("loginUser");
        System.out.println(userName);
        if(userName == null){
            System.out.println(1);
            // 未登录，返回登录页面
            request.setAttribute("msg","没有权限，请先登录");
            // 获取转发器
            request.getRequestDispatcher("/index.html").forward(request,response);
            return false;
        }else{
            System.out.println(2);
            // 成功登录
            return true;
        }
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

```

在config.MyConfig.java 中对自己定义的拦截器进行注册

```java

@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter{

    @Override
    public void addViewControllers(ViewControllerRegistry registry){
        registry.addViewController("/test").setViewName("success");
    }


    @Bean
    public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
        WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("login");
                registry.addViewController("/index.html").setViewName("login");
                registry.addViewController("/main.html").setViewName("dashboard");
            }


            // 用来注册拦截器
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
//                super.addInterceptors(registry);
                // springboot已经做好了静态资源映射，不用拦截器处理静态资源，就可以正常使用，实际操作中需要排除静态资源，要不网页无法正常显示
                // 将/*所用操作进行拦截，然后对静态资源已经登录操作进行排除
                registry.addInterceptor(new 		LoginHandlerInterceptor()).addPathPatterns("/**").excludePathPatterns("/index.html","/","/webjars/**","/user/login");
            }
        };
        return adapter;
    }

    // 将自己定义的Mylocaleresolver组件添加进来

    @Bean
    public LocaleResolver localeResolver(){
        return new MyLocaleResolver();
    }
}

```

主要用到的thymeleaf语法有：

* @{}：url

* #{}：国际化

* [[]]：行内写法

## 3.员工CRUD

要求：

* 1.RestfulCRUD：满足Restful风格

	* URL:/资源名称/资源表示  HTTP请求方式区分对资源CRUD的操作

		|      | 普通CRUD         | RestfulCRUD     |
		| ---- | ---------------- | --------------- |
		| 查询 | getEmp           | emp-GET         |
		| 添加 | addEmp           | emp-POST        |
		| 修改 | updateEmp?id=xxx | emp/{id}--post  |
		| 删除 | deleteEmp?id=1   | emp/{id}-DELETE |

* 2.实验的请求架构

	|                                      | 请求URI  | 请求方法 |
	| ------------------------------------ | -------- | -------- |
	| 查询所有员工                         | emps     | GET      |
	| 查询某个员工                         | emp/{id} | GET      |
	| 来到添加页面                         | emp      | GET      |
	| 添加员工                             | emp      | POST     |
	| 来到修改员工（查出员工信息进行回显） | emp/1    | GET      |
	| 修改员工                             | emp      | PUT      |
	| 删除员工                             | emp/1    | DELETE   |

* 3.员工列表

	thymeleaf公共部分抽取：

	* 1.th:fragment：**将公共片段整个插入到声明的元素中**

		```html
		1.抽取公共部分
		<div th:fragment="copy">
		    &copy;2012 the good news
		</div>
		
		2.引入公共部分
		<div th:insert="~{footer::copy}"></div>
		格式：~{templatename::selector} 模板名：：选择器（片段名）
		
		3.默认效果
		insert的功能片段在div中
		```

	* 2.th:replace：**将声明引入的元素替换成为公共片段**
	* 3.th:include：**将被引入的片段的内容包含进这个标签里面**

	三者的不同之处：

	![image-20210106162521274](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210106162521274.png)

	效果：

```html
insert:
<div>
    <footer>
    &copy;2011 The Good Thymes Virtual Grocery
    </footer>
</div>

replace:
    <footer>
    &copy;2011 The Good Thymes Virtual Grocery
    </footer>

include:包含
<div
    &copy;2011 The Good Thymes Virtual Grocery
</div>
```

# 4.SpringBoot中的错误处理原理

## 1.默认效果：

* 1.浏览器

![image-20210112180809727](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210112180809727.png)

浏览器发送的数据请求头里面会显示接受html

* 2.客户端

![image-20210112213055507](https://bevishe.oss-cn-hangzhou.aliyuncs.com/img/image-20210112213055507.png)

如果是客户端返回的是json数据



原理：ErrorMvcAutoConfiguration；错误处理的自动配置类

给容器中添加了一下组件：

* 1.errorAttributes

* 2.basicErrorController

* 3.errorPageCustomizer

	* ```java
		public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
		      ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath()));
		      errorPageRegistry.addErrorPages(new ErrorPage[]{errorPage});
		}
		```

	* 

* 4.preserveErrorControllerTargetClassPostProcessor

* 1.响应页面

* 2.响应json数据

	

步骤：
一旦系统出现4XX和5XX错误，系统就会

## 2.如果需要自动配置错误响应：

* 1.如何定义错误的页面
* 2.如何定义错误的json数据